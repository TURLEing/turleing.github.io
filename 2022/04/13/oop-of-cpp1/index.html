<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="天泽龟的龟壳屋">
  <link 
    rel="icon" 
    href="https://i.loli.net/2021/07/16/yKghkEQWcY34rOU.jpg">
  <title>Cpp 面向对象入门（其一</title>
  
    
      <meta 
        property="og:title" 
        content="Cpp 面向对象入门（其一">
    
    
      <meta 
        property="og:url" 
        content="https://tzturtle.moe/2022/04/13/oop-of-cpp1/index.html">
    
    
      <meta 
        property="og:img" 
        content="https://i.loli.net/2021/07/16/yKghkEQWcY34rOU.jpg">
    
    
      <meta 
        property="og:img" 
        content="&lt;p&gt;写了四年C++但面向对象啥都不会的我震惊了。&lt;/p&gt;">
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-04-13">
      <meta 
        property="og:article:modified_time" 
        content="2023-07-12">
      <meta 
        property="og:article:author" 
        content="天泽龟">
      
        
      
    
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
      }
    };
    setDarkmode();
    </script>
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
    
    <link rel="prefetch" href="//cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" as="script">
  
  
    
    <link rel="prefetch" href="//unpkg.com/valine/dist/Valine.min.js" as="script">
  
  
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
        <img 
          class="navbar-logo-img" 
          src="https://i.loli.net/2021/07/16/yKghkEQWcY34rOU.jpg" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">天泽龟的龟壳屋</span>
    </span>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首页
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          归档
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          标签
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分类
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          关于
        
      </a>
    
      <a 
        href="/links" 
        class="navbar-menu-item">
        
          友链
        
      </a>
    
      <a 
        href="/bangumis" 
        class="navbar-menu-item">
        
          番剧
        
      </a>
    
    <a 
      class="navbar-menu-item darknavbar" 
      id="dark">
      <i class="iconfont icon-weather"></i>
    </a>
    <a 
      class="navbar-menu-item searchnavbar" 
      id="search">
      <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i>
    </a>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      Cpp 面向对象入门（其一
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-04-13T08:50:49.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-04-13</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/" 
          class="post-meta-link">
          专业学习
        </a>
      
    
    
      <span class="dot"></span>
      <span>3.7k 字</span>
    
  </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <p>写了四年C++但面向对象啥都不会的我震惊了。</p>
<span id="more"></span>
<h1 id="面向对象编程速成"><a class="markdownIt-Anchor" href="#面向对象编程速成"></a> 面向对象编程速成</h1>
<h2 id="一-c-过渡"><a class="markdownIt-Anchor" href="#一-c-过渡"></a> 一。C++ 过渡</h2>
<h3 id="1-引用"><a class="markdownIt-Anchor" href="#1-引用"></a> 1. 引用：</h3>
<p><code>int &amp;r = n</code>，表示 r 是 n 的一个引用，即 r 与 n 等价，修改其一两者都会改变。</p>
<ul>
<li>引用<strong>初始化</strong>时指向某个确定的变量且不可更改；</li>
<li><code>*a 与 &amp;x</code> 地址的调用与引用相当；</li>
<li><strong>函数的引用</strong>等价其返回值。</li>
</ul>
<p>Example: <code>swap(int &amp;a, int &amp;b)</code></p>
<h3 id="2-常量关键字"><a class="markdownIt-Anchor" href="#2-常量关键字"></a> 2. 常量关键字</h3>
<p><code>const int n = 300</code> 或 <code>const int *p = &amp;x</code> 表示常量或常量指针。</p>
<ul>
<li>常量指针不能修改所指向的内容；</li>
<li>普通的指针不能赋常量指针的值（否则与第一条矛盾）</li>
</ul>
<p>特别地， 若函数返回值是 <code>int&amp;</code>，即返回的是返回的地址所指的变量</p>
<h3 id="3-内存动态分配"><a class="markdownIt-Anchor" href="#3-内存动态分配"></a> 3. 内存动态分配</h3>
<ul>
<li><code>P = new T</code>（P 是 <em><em>类型 T</em> 的指针</em>*），开辟 sizeof(T) 大小的内存且将起始地址赋给 P;</li>
<li><code>P = new T[N]</code>（数组），开辟 sizeof(T)*N 的空间且将起始地址赋给 P;</li>
</ul>
<p>可利用 <code>*P = ??</code> 来修改开辟这片空间的内容。</p>
<ul>
<li><code>delete P</code> 或 <code>delete P[]</code>释放空间，其中 P 必须为动态开辟的内存;</li>
</ul>
<h3 id="4-内联函数和重载"><a class="markdownIt-Anchor" href="#4-内联函数和重载"></a> 4. 内联函数和重载</h3>
<ul>
<li><code>inline</code> 将参数入栈后返回调用地址，减小函数调用开销。</li>
</ul>
<p>Example: <code>inline int read() &#123;&#125;</code></p>
<ul>
<li><strong>函数重载</strong>：多个名字相同而参数个数或类型不同，可以使程序直观；</li>
</ul>
<p>Example :</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span> (a&gt;b &amp;&amp; a&gt;c) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(b,c);  <span class="hljs-comment">// 这里的 max 是库里的函数</span><br>&#125;<br></code></pre>
<p><strong>函数缺省</strong> 调用函数时可以让最右侧连续的参数缺省，提高程序可扩展性。</p>
<h2 id="二-类与对象基础"><a class="markdownIt-Anchor" href="#二-类与对象基础"></a> 二。类与对象基础</h2>
<p>在结构化程序设计中 <code>程序 = 数据结构 + 算法</code>，却不能对具有相同事物（变量或函数）进行易于整理的归纳；</p>
<p>而在面向对象程序设计里，一切都是围绕着 <code>对象</code> 展开的（虽然我没有），将数据结构和对应的函数捆绑，形成一个 <code>类</code>，使得<strong>数据结构和算法</strong>与对象呈现紧密联系，我们称其为 <code>封装</code>。</p>
<h3 id="class-定义"><a class="markdownIt-Anchor" href="#class-定义"></a> Class 定义</h3>
<p>C++ 中用 <code>Class</code> 定义一个类，包含了不同的成员变量和成员函数，称其为一个对象。我们可以用 <code>对象名.成员名</code> 对其进行调用。在类的外部写成员函数需要加上类的名字 <code>类型名 对象名:: 函数名()</code> 。</p>
<h3 id="类成员可访问范围"><a class="markdownIt-Anchor" href="#类成员可访问范围"></a> 类成员可访问范围</h3>
<ul>
<li>Private：私有成员，只能在<strong>成员函数内部</strong>访问；</li>
<li>Public: 公有成员，可以在任何位置中使用；</li>
<li>若未定义则默认为 Private.</li>
</ul>
<p>类成员<strong>函数内部</strong>，可以访问到当前对象的全部属性及函数；而在函数之外的地方只能访问其公有成员。</p>
<p>设置私有成员的机制称为 <code>隐藏</code>，使得<strong>只能通过成员函数来访问私有成员</strong>，以后修改成员变量类型等属性后只需修改成员函数而不用修改所有语句。</p>
<h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3>
<p>构造函数可以对对象进行初始化，如给成员变量赋初值，对象生成时构造函数自动被调用（若没写则编译器会生成默认的构造函数）。构造函数无返回值（不用写 return）。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Example</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> ：设计学生姓名年龄成绩的档案。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">private</span> :<br>        <span class="hljs-type">char</span> *name;<br>        <span class="hljs-type">int</span> age;<br>        <span class="hljs-type">double</span> score;<br>    <span class="hljs-keyword">public</span> :<br>        <span class="hljs-built_in">student</span>();  <span class="hljs-comment">// 两个重载的构造函数</span><br>        <span class="hljs-built_in">student</span>(<span class="hljs-type">char</span> *Name, <span class="hljs-type">int</span> Age, <span class="hljs-type">double</span> Score);<br>&#125;;<br><br>student::<span class="hljs-built_in">student</span>() &#123; name = <span class="hljs-string">&quot;&quot;</span>, age = <span class="hljs-number">0</span>, score = <span class="hljs-number">0.0</span>; &#125;<br>student::<span class="hljs-built_in">student</span>(<span class="hljs-type">char</span> *Name, <span class="hljs-type">int</span> Age, <span class="hljs-type">double</span> Score) &#123;<br>    name = Name, age = Age, score = Score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">student <span class="hljs-title">stu1</span><span class="hljs-params">(<span class="hljs-string">&quot;TZ&quot;</span>, <span class="hljs-number">114</span>, <span class="hljs-number">51.4</span>)</span></span>;<br>    student *stu2 = <span class="hljs-keyword">new</span> student;<br>&#125;<br></code></pre>
<h3 id="复制构造函数"><a class="markdownIt-Anchor" href="#复制构造函数"></a> 复制构造函数</h3>
<p>对同类对象引用的构造函数，即为<strong>复制构造函数</strong>，形如 <code>X::X(const X &amp;) &#123;&#125;</code>，除了普通的 <code>A x1 = x2</code> 这类初始化：应注意到这里的<strong>参数应该是引用</strong>，否则会递归地调用复制构造函数。</p>
<ul>
<li>若某个函数有一个<strong>参数是类 A 的对象</strong>，则该函数被调用时，<strong>类 A 的复制构造函数也将被调用</strong>，如：</li>
</ul>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> :<br>        <span class="hljs-built_in">A</span>() &#123;&#125;<br>        <span class="hljs-built_in">A</span>(A &amp;a) &#123; cout&lt;&lt;<span class="hljs-string">&quot;没有赋值捏\n&quot;</span>; &#125;<br>&#125;;<br><span class="hljs-function">voud <span class="hljs-title">Func</span><span class="hljs-params">(A a1)</span> </span>&#123; ... &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a2;   <span class="hljs-built_in">Func</span>(a2); <br>    <span class="hljs-comment">//此时调用了 Func 函数，其参数 a1 会调用复制函数，赋值 a2.</span><br>    <span class="hljs-comment">//但事实上赋值构造函数并非仅可用来复制，比如本例。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>
<ul>
<li>若函数的返回值是类 A 的对象，则返回时 A 的复制构造函数会被调用.</li>
</ul>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> v;<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> n) &#123; v=n; &#125;<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A &amp;a) &#123; v = a.v; cout &lt;&lt;<span class="hljs-string">&quot;复制了捏\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; <span class="hljs-keyword">return</span> b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>().v &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 函数临时生成一个类 A 对象 (4)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre>
<p>同时注意到： <code>A c2=c1</code> 与 <code>A c2(c1)</code> 有时候并非等价。</p>
<h3 id="类型转换构造函数"><a class="markdownIt-Anchor" href="#类型转换构造函数"></a> 类型转换构造函数</h3>
<p>只有一个参数且非复制构造函数，称为类型转换构造函数，将某一类型转换为对象 A，如：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> :<br>        <span class="hljs-type">double</span> r, i;<br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123; r = x, i = <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">//类型转换..</span><br>        <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; r = x, i = y; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)</span></span>; A c2 = <span class="hljs-number">12</span>; <span class="hljs-comment">// 调用类型转换..</span><br>    c1 = <span class="hljs-number">9</span>; <span class="hljs-comment">// 编译器临时生成一个 (9,0) 的A对象，并将其赋值给 c1</span><br>&#125;<br></code></pre>
<h3 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h3>
<p>形如 <code>~ A() &#123;&#125;</code> 的成员函数称为<strong>析构函数</strong>。</p>
<p>当对象消亡时（如<code>return 0</code>, <code>delete</code>）自动调用析构函数，可以帮助对象做一系列善后工作，如释放分配空间等。一个类至多有一个析构函数。</p>
<p>特别的，new 一个类 A 的数组，其每个元素都是一个对象，则会调用多次析构函数.</p>
<h2 id="三-类与对象提高"><a class="markdownIt-Anchor" href="#三-类与对象提高"></a> 三。类与对象提高</h2>
<h3 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h3>
<p>加了 <code>static</code> 关键字的就是静态成员，被所有该类的对象所有共享。因此，静态成员不需要通过某一特定对象访问，可以直接这样写：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> &#123;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>&#125;<br><br>...<br><br>&#123;<br>    A :: <span class="hljs-built_in">Print</span>();  <span class="hljs-comment">// 可以这样直接调用</span><br>&#125;<br></code></pre>
<p>设置静态成员可以将<strong>和某些类紧密相关的变量</strong>联系在一起，防止其他类对其访问，便于维护。但是在定义类时应至少对静态成员变量进行一次<strong>初始化</strong>，否则不可被链接。</p>
<p>值得注意的是，在静态成员函数中，不能访问非静态成员变量/函数（因为静态并不为某一对象独有）;</p>
<h3 id="c-成员函数本质"><a class="markdownIt-Anchor" href="#c-成员函数本质"></a> C++ 成员函数本质</h3>
<p>在 C++ 对象中的一段代码：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A::set</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; price = p; &#125;<br></code></pre>
<p>在 C 中会被翻译成一个多带了一个<strong>指向成员对象的 this 指针</strong>的全局函数，即：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> A *<span class="hljs-keyword">this</span>, <span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;price = p; &#125;<br></code></pre>
<p>在 C++ 中，非静态成员函数也可以直接使用 this 来代表指向该函数作用对象的指针：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">double</span> real, imag;<br>        <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r,<span class="hljs-type">double</span> i) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>        <span class="hljs-function">Complex <span class="hljs-title">Add</span> <span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>-&gt;real++, <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">print</span>();<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">//可直接返回该对象</span><br>        &#125;<br>&#125;<br></code></pre>
<h3 id="成员对象与封闭类"><a class="markdownIt-Anchor" href="#成员对象与封闭类"></a> 成员对象与封闭类</h3>
<p>若一个类的成员是其他类的对象，则称其为 <strong>成员对象</strong>；拥有成员对象的类称为 <strong>封闭类</strong>，如：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tyre</span>&#123;  <span class="hljs-comment">// 描述轮胎的一个类</span><br>    <span class="hljs-keyword">private</span> :<br>        <span class="hljs-type">int</span> radius;<br>        <span class="hljs-type">int</span> width;<br>    <span class="hljs-keyword">public</span> :<br>        <span class="hljs-built_in">Tyre</span>(<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> w) : <span class="hljs-built_in">radius</span>(r), <span class="hljs-built_in">width</span>(w) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> :<br>        <span class="hljs-type">int</span> price;<br>        Tyre ty; <span class="hljs-comment">// 此时 ty 即为一个成员变量</span><br>    <span class="hljs-keyword">public</span> :<br>        <span class="hljs-built_in">Car</span>(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> rr, <span class="hljs-type">int</span> ww) : <span class="hljs-built_in">price</span>(p), <span class="hljs-built_in">Tyre</span>(rr, ww) &#123;&#125;<br>    <span class="hljs-comment">// 此时若未定义构造函数，则默认构造函数会出错</span><br>    <span class="hljs-comment">// Tyre 有其构造函数需要提供参数，编译器不确定</span><br>&#125;<br></code></pre>
<p>封闭类对象生成时，先执行所有成员对象的构造函数，再执行封闭类的构造函数；成员对象的构造函数 <strong>先说明先构造，先构造后析构</strong> 。</p>
<h3 id="常量对象"><a class="markdownIt-Anchor" href="#常量对象"></a> 常量对象</h3>
<p>如果不希望某个对象的值被改变，可以在定义对象时在前面加上 <code>const</code> 关键字。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; <span class="hljs-type">int</span> val; &#125;;<br><span class="hljs-type">const</span> A obj; <span class="hljs-comment">//常量对象定义</span><br></code></pre>
<p>常量对象不可修改，不可调用非常量成员函数。</p>
<p>成员函数说明后也可以加 <code>const</code> 变为常量成员函数，执行期间不能修改对象（指修改成员变量的值，或者调用同类的非常量成员函数）。此外，若有两个成员函数拥有相同的名字和参数表，但有一个是常量，那这属于重载关系。</p>
<p>在函数调用对象作为参数时，生成函数需要调用复制构造函数，效率较低；我们可以通过调用常引用对象，即减少时间浪费，也防止无意中更改实参：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;...&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;o)</span> </span>&#123;...&#125;<br></code></pre>
<h3 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h3>
<p>定义 <strong>友元函数</strong> 或 <strong>友元类</strong> 可以访问该类的私有成员：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive</span> &#123;<br>    <span class="hljs-keyword">public</span> : <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Modify</span><span class="hljs-params">(Car * pcar)</span> </span>&#123; pcar-&gt;price += <span class="hljs-number">1000</span>; &#125;<br>        <span class="hljs-comment">//可以调用Car类的私有成员；</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>     <span class="hljs-keyword">private</span> :<br>        <span class="hljs-type">int</span> price;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">MostExpens</span><span class="hljs-params">( Car cars[], <span class="hljs-type">int</span> tot)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Drive::Modify</span><span class="hljs-params">(Car pcar)</span> </span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MostExpens</span><span class="hljs-params">(Car cars[], <span class="hljs-type">int</span> tot)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++) <br>        mx = <span class="hljs-built_in">max</span>(mx, cars[i].price);  <span class="hljs-comment">// 同上；</span><br>    <span class="hljs-keyword">return</span> mx;<br>&#125;<br></code></pre>
<p>友元不能被传递或继承。</p>
<h2 id="四-运算符重载"><a class="markdownIt-Anchor" href="#四-运算符重载"></a> 四。运算符重载</h2>
<p>重载运算符可以使得C++提供的运算符适用范围得到扩展，<strong>使其作用于对象</strong>。同一运算符，对于不同类型的操作数，其发生的行为也不同。</p>
<p>对于运算符重载的实质是将<strong>运算符函数</strong>进行重载，可以重载为成员函数也可以是全局函数。运算符被多次重载时，可以根据实参类型觉得调用哪个运算符。</p>
<p>可以这样写：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">double</span> real, imag;<br>        <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> r,<span class="hljs-type">double</span> i) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>        Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;c);<br>&#125;<br><br><span class="hljs-comment">// 一个重载加法的全局函数</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;a, <span class="hljs-type">const</span> Complex &amp;b) <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.real+b.real, a.imag+b.imag);<br>    <span class="hljs-comment">// 产生一个临时对象</span><br>&#125;<br><br><span class="hljs-comment">// 重载为成员函数，参数个数为运算符目数减一</span><br>Complex Complex::<span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;c) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real-c.real, imag-c.imag);<br>    <span class="hljs-comment">// 返回一个临时对象</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    Complex c = a+b; c.<span class="hljs-built_in">print</span>();<br>    (a-b).<span class="hljs-built_in">print</span>();  <span class="hljs-comment">// 草，这个可以直接调用，好强；</span><br>    <span class="hljs-comment">//等价于 a.operator-(b)</span><br>&#125;<br></code></pre>
<ol>
<li>重载 <strong>赋值运算符</strong></li>
</ol>
<p>首先应注意到，直接用等号赋值是一种 <strong>浅拷贝</strong>，实质上是直接将指针指向后者的地址（即赋值成员变量的地址）。这不仅会导致原来分配的内存 delete 不掉，还会导致修改 s2 而 s1 也变的尴尬情况。</p>
<p>因此我们需要手动模拟一种 <strong>深拷贝</strong>，即仅修改其内容的赋值语句。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">private</span> : <span class="hljs-type">char</span> *str;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">String</span> ():<span class="hljs-built_in">str</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>]) &#123; str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;&#x27;; &#125;</span><br><span class="hljs-string">        const char *c_str() &#123; return str; &#125;</span><br><span class="hljs-string">        String &amp; operator=( const char &amp;s) &#123; // 深拷贝</span><br><span class="hljs-string">            delete []str; //将原来的内容 delete 掉</span><br><span class="hljs-string">            str = new char[strlen(s)+1]; srtcpy(str, s);</span><br><span class="hljs-string">            // 分配足够的内存并将 s 拷过来。</span><br><span class="hljs-string">            return *this;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        ~String() &#123; delete []str; &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">int main() </span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    String s; s = &quot;2&quot;; </span><br><span class="hljs-string">    String S0 = &quot;1&quot;; // 出错，没有设定构造函数</span><br><span class="hljs-string">    String s1 = s; // 不合适，本质上是指针 s1 指向 s.</span><br><span class="hljs-string">    // 直接赋值地址被称为浅拷贝。 </span><br><span class="hljs-string">&#125;</span><br></code></pre>
<p>赋值运算符的类型选取 <code>String &amp;</code> 的原因是，赋值运算本质上返回的是左边元素的一个引用。如 <code>(a=b)=c</code>，返回 a 的引用。</p>
<ol>
<li>STL 中 vector 的实现</li>
</ol>
<p>利用运算符重载等功能，可实现一个可变长数组。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Carray</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> sz; <span class="hljs-type">int</span> *ptr;<br>    <span class="hljs-comment">//指向动态分配的数组</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Carray</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>) : <span class="hljs-built_in">size</span>(s) &#123; <span class="hljs-comment">//构造函数</span><br>            <span class="hljs-keyword">if</span> (s==<span class="hljs-number">0</span>) ptr = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">else</span> ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[s];<br>            <span class="hljs-comment">// 若初始化有元素，则应该开辟一系列空间</span><br>        &#125; <br>        <br>        <span class="hljs-built_in">Carray</span>(Carray &amp;a) &#123;<span class="hljs-comment">// 复制构造函数</span><br>            <span class="hljs-keyword">if</span> (!a.ptr) &#123; ptr=<span class="hljs-literal">NULL</span>, sz=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>; &#125;<br>            ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[a.sz];<br>            <span class="hljs-built_in">memcpy</span>(ptr, a.ptr, a.sz&lt;&lt;<span class="hljs-number">2</span>); <br>            sz = a.sz; <span class="hljs-comment">//进行深拷贝</span><br>        &#125;<br>        <br>        ~<span class="hljs-built_in">Carray</span>() &#123;<br>            <span class="hljs-keyword">if</span> (ptr) <span class="hljs-keyword">delete</span> []ptr;<br>        &#125;<br><br>        Carray &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Carray &amp;a) &#123;<br>        <span class="hljs-comment">// 同理应进行深拷贝</span><br>            <span class="hljs-keyword">if</span> (ptr==a.ptr) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 应付a=a的情况</span><br>            <span class="hljs-keyword">if</span> (a.ptr==<span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ptr) <span class="hljs-keyword">delete</span> []ptr;<br>                ptr = <span class="hljs-literal">NULL</span>, sz=<span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ptr) <span class="hljs-keyword">delete</span> []ptr; <br>            ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[a.sz];<br>            <span class="hljs-built_in">memcpy</span>(ptr, a.ptr, a.sz&lt;&lt;<span class="hljs-number">2</span>), sz = a.sz;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (ptr) &#123;<br>                <span class="hljs-type">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[sz+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 多分配一个空间给 \0</span><br>                <span class="hljs-built_in">memcpy</span>(tmp, ptr, sz&lt;&lt;<span class="hljs-number">2</span>); <span class="hljs-keyword">delete</span> []ptr;<br>                ptr = tmp;<br>            &#125;<br>            <span class="hljs-keyword">else</span> ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1</span>];<br>            ptr[sz++] = v;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> sz; &#125;<br>        <br>        <span class="hljs-type">int</span> &amp; Carray::<span class="hljs-keyword">operator</span>[] (<span class="hljs-type">int</span> i)<br>        &#123; <span class="hljs-keyword">return</span> ptr[i]; &#125;<br>        <span class="hljs-comment">// 重载 []，使得可直接访问内部数组的元素</span><br>        <span class="hljs-comment">// 非引用的函数返回值不可作为左值使用。</span><br>&#125;<br></code></pre>
<ol start="4">
<li>流插入运算符的重载</li>
</ol>
<p>代码里 <code>cout &lt;&lt; 5 &lt;&lt; &quot;hello&quot;</code> 这种代码之所以可以运行，是因为在 iostream 库中定义的 ostream 类对象对 <code>左移&lt;&lt;</code> 操作进行了重载。即可以写作：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>     os &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; p.y; <br>     <span class="hljs-keyword">return</span> os;<br> &#125;<br> <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p) &#123;<br>     <span class="hljs-type">int</span> x, y;<br>     is &gt;&gt; x &gt;&gt; y, p.x = x, p.y = y;<br>     <span class="hljs-keyword">return</span> is;<br> &#125;<br></code></pre>
<p>如果我们想要使流插入对自定义类同样适用，则需要对其重载，比如：</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-comment">// 内置不进ostream类，重载成全局函数</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;o, <span class="hljs-type">const</span> A &amp;s) &#123;<br>    o &lt;&lt; s.x; <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre>
<ol start="5">
<li>类型转换运算符的重载</li>
</ol>
<p>强制类型转换本质上是一个函数，那我们就可以对该函数重载。</p>
<pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>    <span class="hljs-type">double</span> real, imag;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> i=<span class="hljs-number">0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;;<br>        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> real; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1.1</span>, <span class="hljs-number">4.1</span>)</span></span>;<br>    cout &lt;&lt; (<span class="hljs-type">double</span>)c &lt;&lt; endl;<br>    <span class="hljs-type">double</span> n = <span class="hljs-number">2</span>+c; <span class="hljs-comment">// 隐式类型转换</span><br>    cout &lt;&lt; n &lt;&lt; endl;<br>&#125;<br></code></pre>
<ol start="6">
<li>自增自减运算符的重载<br />
前置运算符作为一元运算符重载，而后置运算符作为二元运算符重载；</li>
</ol>
<pre class="highlight"><code class="hljs cpp">T &amp;<span class="hljs-keyword">operator</span>++();  <span class="hljs-comment">// 前置，返回一个T的引用</span><br>T <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// 后置，返回一个T类型</span><br><br>T&amp; T::<span class="hljs-keyword">operator</span>++() &#123; ++x; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>T T::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> k) &#123; <br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>; n++; <span class="hljs-keyword">return</span> tmp; <br>    <span class="hljs-comment">// 返回修改前的对象</span><br>&#125;<br></code></pre>
<p>之所以<strong>前置是它的引用</strong>，因为 C 语言内部本身如此，这样搞符合原生态C语言特性（比方说 <code>(++a) = 1</code> 这句，最后得到 a 的值为 1.</p>
<p>后置运算符返回的是<strong>临时变量</strong>，因此 <code>(a++) = 1</code> 没啥影响。</p>
<p>由于前置运算是直接引用，没有产生新的对象，因此会比后置运算快一点点（如果在 STL 中抓一个迭代器做循环，应该写成 <code>for (it = a.begin(); it != a.end(); ++it)</code>。</p>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            天泽龟
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="https://tzturtle.moe/2022/04/13/oop-of-cpp1/">
            https://tzturtle.moe/2022/04/13/oop-of-cpp1/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/04/13/oop-of-cpp2/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
            <div class="nav-title">Cpp 面向对象入门（其二 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/02/09/CSAPP-chatper-6/" 
        class="nav-link">
        <div>
          <div class="nav-label">下一篇</div>
          
            <div class="nav-title">CSAPP 第六、九章小姐：内存与虚拟内存 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

  <div 
    class="card card-content comment-card" 
    style="margin-top: 16px;">
    <div class="comment-card-title">评论</div>
    
  <div id="vcomments"></div>
  
  <script>
    loadScript("//unpkg.com/valine/dist/Valine.min.js");
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();
      new Valine({
        el: '#vcomments',
        appId: '4CiiPBXpbjDnPvIIwfuEPEY6-gzGzoHsz',
        appKey: '3AQY35K3Laq9fLvTG2uOHDUT',
        placeholder: '留下你的评论...',
        path: window.location.pathname,
        avatar: 'identicon',
        meta: ["nick","mail","link"],
        pageSize: '10',
        lang: '',
        visitor: 'false',
        highlight: true,
        recordIP: false,
        
        
        
        enableQQ: 'true',
        requiredFields: [],
      });
    };
  </script>

  </div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%80%9F%E6%88%90"><span class="toc-text"> 面向对象编程速成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-c-%E8%BF%87%E6%B8%A1"><span class="toc-text"> 一。C++ 过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8"><span class="toc-text"> 1. 引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> 2. 常量关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text"> 3. 内存动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text"> 4. 内联函数和重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-text"> 二。类与对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class-%E5%AE%9A%E4%B9%89"><span class="toc-text"> Class 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4"><span class="toc-text"> 类成员可访问范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 复制构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 类型转换构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98"><span class="toc-text"> 三。类与对象提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text"> 静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8"><span class="toc-text"> C++ 成员函数本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-text"> 成员对象与封闭类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 常量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text"> 友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text"> 四。运算符重载</span></a></li></ol></li></ol>
</div></main>
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="https://i.loli.net/2021/07/16/yKghkEQWcY34rOU.jpg" 
    class="author-img" 
    alt="author avatar">

<p class="author-name">天泽龟</p>
<p class="author-description">天泽龟的龟是龟裂的龟哦。</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>61</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>5</span>
    <span>分类</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>15</span>
    <span>标签</span>
  </a>
</div>

  <div class="author-card-society">
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/12645985">
          <i class="iconfont icon-bilibili society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://github.com/TURLEing">
          <i class="iconfont icon-github society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://turleing.github.io/about/">
          <i class="iconfont icon-mail society-icon"></i>
        </a>
      </div>
    
  </div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%80%9F%E6%88%90"><span class="toc-text"> 面向对象编程速成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-c-%E8%BF%87%E6%B8%A1"><span class="toc-text"> 一。C++ 过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8"><span class="toc-text"> 1. 引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> 2. 常量关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text"> 3. 内存动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text"> 4. 内联函数和重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-text"> 二。类与对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class-%E5%AE%9A%E4%B9%89"><span class="toc-text"> Class 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4"><span class="toc-text"> 类成员可访问范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 复制构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 类型转换构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98"><span class="toc-text"> 三。类与对象提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text"> 静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8"><span class="toc-text"> C++ 成员函数本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-text"> 成员对象与封闭类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 常量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text"> 友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text"> 四。运算符重载</span></a></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分类
  </div>
  <div class="categories-list">
    
      <a href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">
        <div class="categories-list-item">
          算法竞赛
          <span class="categories-list-item-badge">12</span>
        </div>
      </a>
    
      <a href="/categories/%E7%94%9F%E6%B4%BB%E5%88%86%E4%BA%AB/">
        <div class="categories-list-item">
          生活分享
          <span class="categories-list-item-badge">10</span>
        </div>
      </a>
    
      <a href="/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">
        <div class="categories-list-item">
          专业学习
          <span class="categories-list-item-badge">27</span>
        </div>
      </a>
    
      <a href="/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/">
        <div class="categories-list-item">
          科研学习
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/%E7%A4%BE%E5%9B%A2%E6%8E%A8%E9%80%81/">
        <div class="categories-list-item">
          社团推送
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>热门标签
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" 
        title="计算机组成原理">
        <div class="tags-list-item">计算机组成原理</div>
      </a>
    
      <a 
        href="/tags/%E9%9A%8F%E7%AC%94/" 
        title="随笔">
        <div class="tags-list-item">随笔</div>
      </a>
    
      <a 
        href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" 
        title="强化学习">
        <div class="tags-list-item">强化学习</div>
      </a>
    
      <a 
        href="/tags/NLP/" 
        title="NLP">
        <div class="tags-list-item">NLP</div>
      </a>
    
      <a 
        href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" 
        title="操作系统">
        <div class="tags-list-item">操作系统</div>
      </a>
    
      <a 
        href="/tags/%E6%97%A5%E9%BA%BB/" 
        title="日麻">
        <div class="tags-list-item">日麻</div>
      </a>
    
      <a 
        href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" 
        title="大模型">
        <div class="tags-list-item">大模型</div>
      </a>
    
      <a 
        href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" 
        title="字符串">
        <div class="tags-list-item">字符串</div>
      </a>
    
      <a 
        href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" 
        title="分布式">
        <div class="tags-list-item">分布式</div>
      </a>
    
      <a 
        href="/tags/%E6%83%85%E6%84%9F%E8%AE%A1%E7%AE%97/" 
        title="情感计算">
        <div class="tags-list-item">情感计算</div>
      </a>
    
      <a 
        href="/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" 
        title="多项式">
        <div class="tags-list-item">多项式</div>
      </a>
    
      <a 
        href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" 
        title="推荐系统">
        <div class="tags-list-item">推荐系统</div>
      </a>
    
      <a 
        href="/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/" 
        title="强连通分量">
        <div class="tags-list-item">强连通分量</div>
      </a>
    
      <a 
        href="/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/" 
        title="线性基">
        <div class="tags-list-item">线性基</div>
      </a>
    
      <a 
        href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" 
        title="博弈论">
        <div class="tags-list-item">博弈论</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目录
</div>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%80%9F%E6%88%90"><span class="toc-text"> 面向对象编程速成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-c-%E8%BF%87%E6%B8%A1"><span class="toc-text"> 一。C++ 过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8"><span class="toc-text"> 1. 引用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text"> 2. 常量关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text"> 3. 内存动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text"> 4. 内联函数和重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-text"> 二。类与对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class-%E5%AE%9A%E4%B9%89"><span class="toc-text"> Class 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%8C%83%E5%9B%B4"><span class="toc-text"> 类成员可访问范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 复制构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text"> 类型转换构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text"> 析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98"><span class="toc-text"> 三。类与对象提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text"> 静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8"><span class="toc-text"> C++ 成员函数本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%B0%81%E9%97%AD%E7%B1%BB"><span class="toc-text"> 成员对象与封闭类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text"> 常量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text"> 友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text"> 四。运算符重载</span></a></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最近文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-09-28</div>
        <a href="/2025/09/28/CS336/"><div class="recent-posts-item-content">CS336 学习笔记 Part 1：从模型架构变体到底层硬件优化</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-08-15</div>
        <a href="/2025/08/15/my-interest-in-ag/"><div class="recent-posts-item-content">现代大模型时代下的情感计算综述</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-07-21</div>
        <a href="/2025/07/21/Rl-reproduce/"><div class="recent-posts-item-content">RL 实验复现随笔【Tool Agent】【PPO、GRPO】</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-07-16</div>
        <a href="/2025/07/16/daily-story-pyenv-conda/"><div class="recent-posts-item-content">【实验室小品一则】什么是pyenv，什么是miniconda</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2020 -
          
          2025
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          天泽龟的龟壳屋
        </a>
      </div>
    </div>

    
      <div class="footer-dsc">
        
          Powered by
          <a 
            href="https://hexo.io/" 
            class="footer-link" 
            target="_blank" 
            rel="nofollow noopener noreferrer">
            &nbsp;Hexo
          </a>
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          Theme -
          <a 
            href="https://github.com/theme-kaze" 
            class="footer-link" 
            target="_blank"
            rel="nofollow noopener noreferrer">
            &nbsp;Kaze
          </a>
        
      </div>
    
    
    
    
      <div class="footer-dsc">
        
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer> 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton" 
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
      

  
  
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">

  
 
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
    
      <script> 
        loadScript('/js/lib/busuanzi.min.js') 
      </script>
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
     
    
    
  </body>
</html>
